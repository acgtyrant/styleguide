## Google Guide Style 笔记

右值引用：居然只提倡用在移动构造函数和移动赋值操作，似乎忽略了完美转发问题？

3.1. 看来 Google 真是怕异常了，构造函数不得进行过于复杂的初始化，宁可牺牲性能也要委托给 Init() 函数。

1.1. 大家平时都提倡分离式编译，即声明放头文件，实现放 `.cc` 里。然而模板不一样，如果一个用到了函数模板或类模板的 `.cc` 文件里连同它所包含的头文件都没有模板具体实现代码，只有声明，那么不论它所链接的其它 `.cc` 有没有模板具体实现代码，都会因为找不到其模板定义，从而特例化失败，除非所包含模板具体实现代码的 `.cc` 文件同时显式实例化了函数声明。这是很常见的 C++ 新手错误。

但据说显式实例化技术可读性差。总而言之，还是直接把模板定义放进头文件就好。话说回来，可以借此重温一下分离式编译的知识，其实就算把实现放到头文件一样能隐藏源代码，毕竟直接向客户只提供其编译成的二进制库或包就行了。要牢记，一切都是为了方便写代码，虽然 C/C++ 的编译模型本身落伍得难用。

[C语言头文件组织与包含原则}(http://www.cnblogs.com/clover-toeic/p/3728026.html)值得留意。

派生类的构造函数必须在初始化列表显示初始化基类成员，哪怕用后者的默认构造函数。

定义基于对象的类时，就显式声明为 final, 阻止继承。

虚函数用三个关键字之其一：`virtual`, `override`, `final`, 后两种包含前者。

派生类对基类的访问符要显式声明，以致无需弄清 class 和 struct 的区别。

# Effective C++

## 条款三

当 const 和 non-const 成员函数实现等价时，优先定义前者，后者就通过 const_cast 地调用前者。

标准的 const 可能贯彻 bitwise const, 然而有必要时，我们也可以遵循 logical const, 于是可以用 mutable 重新修饰相关数据成员。

## 条款四

尽量避免用一个成员来初始化另一个成员，不然要处理好它们在类中的声明顺序。

## 条款五

为了搞清楚您到底想要什么样的类，构造、复制、移动、赋值、祈构统统都要显式声明，可以用 `default` 或 `delete` 来简化。

## 条款七

明确类是否需要运行时多态。若需要，那么一定会有 virtual 成员函数，祈构函数相应地也要加 `virtual` 参数，以能够让派生类在运行时多态时能正确地把被析构。反之，就意味着不能当 base class 用了，STL 容器就是如此；此外，加 `virtual` 参数会额外占用空间。

## 条款八

析构函数绝对不能吐出异常。如果一个被析构函数调用的函数可能会抛出异常，那析构函数应该能捕捉这些异常，且要么吞下，要么中断。

如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数中）执行该操作。

## 条款九

不要在构造函数和析构函数调用虚函数，因为这类调用不会下降到 derivec class, 换言之构造函数和析构函数的内部不贯彻运行时多态。
消费
## 条款十

赋值操作符返回 reference to *this

## 条款十一

赋值运算符应该能够处理自我赋值的情况，可以贯彻 copy and swap 惯用法。推广之，则确保任何操作一个以上对象的函数，能在所有参数都是同一个对象时，依然执行正确。

## 条款十二

确保每增加新私有变量时，同步更新所有显式定义的拷贝控制函数。derived class 的 copying 函数要直接调用 base class 的 copying 函数。

别试图用 copy 构造函数和赋值操作符中的一个函数代替另一个函数。

## 条款十四

妥当处理好 RAII 类的 copying 行为，可以 delete 或引用计数地共享。

## 条款十五

RAII 的初衷只有确保资源在脱离作用域时能被及时释放而已，对原始资源的访问并不违背封装原则，于是有必要时就提供后者，可以直接像 std::shared_ptr 一样提供 get 函数。

## 条款十六

new/delete 精确地同时使用或不使用 `[]`; 于是尽量避免 typedef 数组，否则后者带来 `new/delete []` 上的隐患。

## 条款十七

不要在形参里将 new 语句传给智能指针构造函数，因为有可能由于形参里的另一个函数调用发生异常中断而造成资源泄漏。

## 条款十八

精心设计好用的接口，可以靠类型系统强化鲁棒性、保持接口高度一致、与内置类型行为兼容、杜绝客户手动管理资源的负担等等。

## 条款十九

设计 class 如同设计新 type: 精确拷贝控制，规定合法值，设计继承图系，定义成员函数和操作符，封装，模板化，有无必要等等。

## 条款二十

优先用 pass by reference to const 代替 pass by value. 一来可以避免对象切割问题，即 derived class 对象不会被 base class 的复制构造函数害得只有前者变成了后者；二来效率更高；

不过内置类型，STL 迭代器和函数对象只能用 pass by value.

## 条款二十一

考虑好你要返回引用还是对象；别返回指向 locak stack 的 pointer 和 reference, 或返回指向 heal-allocated 的 reference.

## 条款二十二

最好把所有数据成员声明为 private, 一来客户直接调用由官方精心控制的 API, 二来封装够碾压。此外 protected 的封装性和 public 一样弱。

## 条款二十三

优先用 non member non friend 函数替换 member 函数，毕竟一样的功能，但前者却不能访问私有成员，这才贯彻封装。此外，带来的好处也不少：这函数可以是另一个 class 的 member 函数，也可以是一个跨文件的命名空间里的函数。

## 条款二十四

如果需要某函数的所有参数都能进行隐式转换，那么得定义为 non-menber 函数，特别是二元运算符。此外，member 的反面不应该全是 friend.

## 条款二十五

copy and swap.

## 条款二十六

到确实要用变量时才定义，并且直接在构造的同时初始化，不要构造后再赋值。此外，优先在循环内构造变量，除非明确赋值成本远低于构造析构且不在乎作用域污染。

## 条款二十八

禁止返回指向函数内部的 handler（包括引用、指针和迭代器）。

## 条款二十九

异常安全有三种级别：保证数据有效的基本型，保证调用成功就是成功调用失败就当没调用过的强烈型和完全不抛任何异常的最终型。可以靠 copy and swap 实现强烈型，`noexcept` 实现最终型。

## 条款三十

一开始不考虑 inline, 直到开始优化时就把 inline 用在那个 20% 的函数上。

## 条款三十一

不管 pImpl, 坐等传说中的 Module 解决这问题。

## 条款三十二

public 继承：[吾派生类澄如基类……！所作所为皆为「基类」。](https://zh.moegirl.org/zh-hans/%E5%90%BE%E5%BF%83%E5%90%BE%E8%A1%8C%E6%BE%84%E5%A6%82%E6%98%8E%E9%95%9C%EF%BC%8C%E6%89%80%E4%BD%9C%E6%89%80%E4%B8%BA%E7%9A%86%E4%B8%BA%E6%AD%A3%E4%B9%89)

## 条款三十三

当派生类所重载的函数会名称遮掩基类的所有同名函数，using 后者即可；若要在 private 继承前提下指定继承某特定函数，则定一个简单的转交函数。

## 条款三十四

纯虚函数表示派生类继承其接口，后者一定要自行定义实现；
虚函数表示派生类继承接口与其实现，前者可以 override 后者；
普通函数表示派生类强制继承其接口与实现。

如果一个派生类Ｂ private 继承某基类Ａ，那么Ｂ的派生类Ｃ无法继承Ａ的任何函数，包括虚函数。
虽说「普通函数表示派生类强制继承其接口与实现」，然而就我对名称遮掩的印象来看，派生类照样可以 override 一个和基类某普通函数一模一样的函数，我猜 C++11 引入 final 旨在解决的问题之一是这个。

## 条款四十二

因为 C++ 在解析嵌套从属类型名称（nested dependent type name）时并不会优先假定它是「类型」，于是得显式地在所有嵌套从属类型名称前统统加上 `typename`.

但有两个例外：

* base class lists, 即继承的 base class 列表，毕竟其向来只能是类型即 class.
* member initialization list, 即成员初始化列表，毕竟其向来只能是对象即数据成员。

我曾对此规则产生了疑问，后来自己解决了：[嵌套从属名称在成员初始化列表如何被分别解析为类型或数据成员？](http://segmentfault.com/q/1010000004034584/a-1020000004034914)

# More Effective C++

## 条款一

当你要指向非 null 的某东西，也不会再改指向其它东西，或实现一个操作符需要直接引用，就引用；否则可以用指针。

## 条款三

数组没有多态，死心吧。

## 条款四

若类的构造依赖上下文，则不提供默认构造函数；不过有两个麻烦：无法直接构造数组，小心翼翼地模板化。

也许可以通过 placement new 构造数组。

## 条款五

禁止定义隐式类型转换操作符，用功能对等的另一个函数取代类型转换操作符；显式用 explicit 关键字杜绝一切隐式转换，当然显式转换可行；C++11 后，所有常规构造函数都可以用 explicit 了。

## 条款六

后置式 increment/decrenment 操作符要返回 const 对象；而且由于是临时对象，涉及到构造和析构，所以前置式更优；后置式操作符直接委托前置式操作符。

## 条款七

禁止重载 &&, || 和 , 操作符。因为会改变「骤死式语义」成「函数调用语义」。

## 条款二十二

优先重载复合运算符，接着让常规运算符委托前者，后者只需构造一次临时变量。

## 其它

不用默认参数；若数据成员不依赖构造函数的上下文，则用类内初始值，反之用构造函数初始值列表。

本指南原则上提倡所有定义形参都要有名字，然而有个例外：重载的后置式自增／自减运算符，以及用 `default` 或 `delete` 定义的赋值控制函数。

我以为 friend 声明只提供访问权限，是无效的声明——大错特错！[实际上有效，只不过作用域更为狭窄，且 C++ 可以通过 ADL 在类内作用域找到形参有涉及类的函数声明](http://stackoverflow.com/questions/32175304/is-the-friend-declaration-a-real-declaration)。 但为了一致性以及安全，还是照样继续在类作用域声明。

虽然 Google Guide Style 无所谓，但 Effective C++（第二版）第四条指出建议用 C++ 风格，详见 [C++ 工程实践(3)：采用有利于版本管理的代码格式](http://blog.csdn.net/solstice/article/details/6225538)

如果是像复数类的实部和虚数、Rect 类的 width 和 height 那样有共同性质的变量，在不超过 80 列的前提下可以一块声明。

写包含模板定义的头文件时，其所用的匿名空间就用名字为小写加下划线的文件名的命名空间代替，比如在 `merge-sort.h` 里，匿名空间命名为 `merge_sort_h_`, 正好与头文件防护的宏命名规则对应且区分鲜明。

[平时定义模板时，`class` 和 `typename` 一般没有区别，优先用 `typename`. 不过定义模板中模板时，用 `class` 定义模板内的模板；用 `typename` 强调某物是类型。](http://stackoverflow.com/a/2024173/1546088)

对变量的定义也贯彻拖延战术，虽然实现一般并不会有相应的优化，但可读性好。

优先用大括号初始化。

研究利于分支预测优化的编程风格。

在函数里，尽量不通过引用修改对象，而是返回对象以赋值回前者。除非用 malloc 开销大的 std::vector, 此外 const 形参要放在前面，非 const 形参在后。

禁忌の三重存在：`T const *const operator *() const;`.

理想的生产环境：[C++项目管理](https://yq.aliyun.com/articles/74?spm=5176.100240.searchblog.8#index_section)

lambda 的捕获列表尽量写所要捕获的 indentifier 而不是符号，这样可以避免函数体意外捕获到其他 identifier.

### STL

必要时，可以用 `std::back_inserter` 来辅助地复制一对迭代器范围内的值到另一个迭代器：
```cpp
assert(y.size() == 0);
std::copy(x.begin(), x.end(), std::back_inserter(y));
```

可以用 `at` 代替 `operator[]`. 前者越界时会抛异常。

### 重载

重载输出运算符，尽量少格式化操作好；重载输入运算符要处理好可能的错误。

有些可重载的运算符往往自成一对，即 == 和 !=, > 和 <, * 和 ->, 为了贯彻直觉与一致性，优先重载前者，并让后者委托前者。此外我在写复数类时突发奇想，如果某类需要重载加减乘除，那么意味着它本身构成一个环，我们可以为它定义加法逆元和乘法逆元函数，再让减法运算符和除法运算符以及复合赋值运算符委托这两个函数。出于一致性，函数名分别叫 AdditiveInverse 和 MultiplicativeInverse. 虽然这可能对不懂抽象代数的同行不友好。

同理，`operator ->()` 可委托 `operator *()`, `operator ++(int)` 可委托 `operator ++()`:

```cpp
T const *operator ->() {
    return &this->operator *();
} 

T const operator ++(int) {
    T tmp(*this);
    this->operator ++();
    return tmp; }
```

不过，若 `operator &()` 也被重载且不一致的话，那么用 `std::addressof` 代替它。

重载泛型化的运算符，可以善用 <functional> 提供的算术运算符、关系运算符和逻辑运算符的类。

## 其它

如果重载的运算符需要与非类类型交互且支持隐式转换，则声明为非成员函数，否则就声明成只与同类类型对象交互的成员函数。

不过原则上本来就不鼓励隐式转换。

重载输出运算符，尽量少格式化操作好。

重载输入运算符要处理好可能的错误。

重载成员函数时，要么都有引用符，要么都没有。

类内初始值 vs 默认参数 vs 构造函数初始值列表？类内初始值优先！

有些可重载的运算符往往自成一对，即 == 和 !=, > 和 <, * 和 ->, 为了贯彻直觉与一致性，优先重载前者，并让后者委托前者。此外我在写复数类时突发奇想，如果某类需要重载加减乘除，那么意味着它本身构成一个环，我们可以为它定义加法逆元和乘法逆元函数，再让减法运算符和除法运算符以及复合赋值运算符委托这两个函数。出于一致性，函数名分别叫 AdditiveInverse 和 MultiplicativeInverse. 虽然这可能对不懂抽象代数的读者不友好 (ﾟ∀。)

重载泛型化的运算符，可以善用 <functional> 提供的算术运算符、关系运算符和逻辑运算符的类。

本指南原则上提倡所有定义形参都要有名字，然而有个例外：重载的后置式自增／自减运算符，以及用 `default` 或 `delete` 定义的赋值控制函数。

我以为 friend 声明只提供访问权限，是无效的声明——大错特错！实际上有效，只不过作用域更为狭窄，且 C++ 可以通过 ADL 在类内作用域找到它的声明。http://stackoverflow.com/questions/32175304/is-the-friend-declaration-a-real-declaration 但为了一致性以及安全，还是照样继续在类作用域声明。

虽然 Google Guide Style 无所谓，但 Effective C++（第二版）第四条指出建议用 C++ 风格，详见 C++ 工程实践(3)：采用有利于版本管理的代码格式 http://blog.csdn.net/solstice/article/details/6225538

鉴于我的经验，按 Google Guide Style 命名变量名，往往很长，那么就更该一行代码只定义一个变量了。不过如果是像复数类的实部和虚部那样有共同性质的变量，在不超过 80 列的前提下也可以一块声明。

函数形参很长，往往要断行并缩进四格，再分拆成多行。于是只能在只有一个形参且不超过 80 列的情况下，形参与函数名同行。此外，若将来形参名和数量发生变动，那么从同行到断行的变化是不可逆转的。不建议分拆多行时还让第一个形参和函数名同行，毕竟函数名本身也可以变化，保持缩进很麻烦，也不利于 git blame.

alloctor 比传统 new/delete 高明多了，毕竟分离了分配内存和构造，优化余地更大。

inline 必须放在模板名之后。

写包含模板定义的头文件时，其所用的匿名空间就用名字为小写加下划线的文件名的命名空间代替，比如在 `merge-sort.h` 里，匿名空间命名为 `merge_sort_h_`, 正好与头文件防护的宏命名规则对应且区分鲜明。

[平时定义模板时，`class` 和 `typename` 一般没有区别，优先用 `typename`. 不过定义模板中模板时，用 `class` 定义模板内的模板；用 `typename` 强调某物是类型。](http://stackoverflow.com/a/2024173/1546088)

对变量的定义也贯彻拖延战术，虽然实现一般并不会有相应的优化，但可读性好。

优先用大括号初始化。

http://www.zkt.name/c-s-most-vexing-parse/ 研究下用列表初始化全面代替其他初始化形式的可行性。copy elision vs RVO?

研究利于分支预测优化的编程风格。

优先用 `at` 代替 `operator[]`. 前者有边界检查；此外 `std::map::at` 不会违背 const 属性，后者则反。

## Google Guide Style 笔记

右值引用：居然只提倡用在移动构造函数和移动赋值操作，似乎忽略了完美转发问题？

3.1. 看来 Google 真是怕异常了，构造函数不得进行过于复杂的初始化，宁可牺牲性能也要委托给 Init() 函数。

1.1. 大家平时都提倡分离式编译，即声明放头文件，实现放 `.cc` 里。然而模板不一样，如果一个用到了函数模板或类模板的 `.cc` 文件里连同它所包含的头文件都没有模板具体实现代码，只有声明，那么不论它所链接的其它 `.cc` 有没有模板具体实现代码，都会因为找不到其模板定义，从而特例化失败，除非所包含模板具体实现代码的 `.cc` 文件同时显式实例化了函数声明。这是很常见的 C++ 新手错误。

但据说显式实例化技术可读性差。总而言之，还是直接把模板定义放进头文件就好。话说回来，可以借此重温一下分离式编译的知识，其实就算把实现放到头文件一样能隐藏源代码，毕竟直接向客户只提供其编译成的二进制库或包就行了。要牢记，一切都是为了方便写代码，虽然 C/C++ 的编译模型本身落伍得难用。

[C语言头文件组织与包含原则}(http://www.cnblogs.com/clover-toeic/p/3728026.html)值得留意。

派生类的构造函数必须在初始化列表显示初始化基类成员，哪怕用后者的默认构造函数。

定义基于对象的类时，就显式声明为 final, 阻止继承。

留意成员函数的引用限定符。

显式用 virtual 声明所有虚函数？

覆盖派生类的虚函数定义时，显式用上 `override`.

所有的虚函数默认实参保持一致，否则会依静态类型不同而不同。

派生类虚函数可以通过作用域访问符调用基类虚函数。

派生访问符要显式声明，以致无需弄清 class 和 struct 的区别。

别在派生类重用名字吧？ 

通过把复制构造函数放到 `private` 区段以禁用的作法过时了，请用 C++11 特性 `delete`.

用库函数的返回值做除法时，注意返回值的类型，比如 cv::Rect::area() 的 类型就为 int, 计算矩形的重叠面积就会失足。

# Effective C++

## 条款二

优先声明成 const 函数，非 const 函数就通过转型调用前者。

函数返回值会构造一个临时对象，也就是说理论上可以被赋值，然而此行为无益，于是编译器规定若返回值并非是指针或引用，不是有效的左值，自然也不能被赋值。此外，当返回值是指针或引用，当然可以用 const.

## 条款四

尽量避免用一个成员来初始化另一个成员，不然要处理好它们在类中的声明顺序。

## 条款五

构造、复制、赋值、祈构都要显式声明，可以用 `default` 或 `delete` 来简化。

## 条款七

明确祈构函数是否需要 `virtual` 参数。如果不加，意味着不能当 base class 用 STL 容器就是如此，此外，加了 `virtual` 参数会害得类占用额外的空间。

## 条款八

析构函数绝对不能吐出异常。如果一个被析构函数调用的函数可能会抛出异常，那析构函数应该能捕捉这些异常，且要么吞下，要么中断。

如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数中）执行该操作。

## 条款九

不要在构造函数和析构函数调用虚函数，因为这类调用不会下降到 derivec class.

## 条款十

赋值操作符返回 reference to *this

## 条款十一

赋值运算符应该能够处理自我赋值的情况。推广之，则确保任何操作一个以上对象的函数，能在所有参数都是同一个对象时，依然执行正确。

## 条款十二

derived class 的 copying 函数要直接调用 base class 的 copying 函数。

别试图用 copy 构造函数和赋值操作符中的一个函数代替另一个函数。

## 条款二十

优先用 pass by reference to const 代替 pass by value. 一来可以避免对象切割问题，即 derived class 对象不会被 base class 的复制构造函数害得只有后者的成员传递进去；二来效率更高；

不过内置类型，STL 迭代器和函数对象只能用 pass by value, 毕竟 STL 容器本来不能被当成 base class 用。

## 条款二十一

别返回指向 locak stack 的 pointer 和 reference, 或返回指向 heal-allocated 的 reference.

## 条款二十二

所有数据成员必须统统声明为 private, 一来客户不必琢磨要不要用函数调用符，二来压倒性的封装。此外 protected 并不如 private 有封装性。

## 条款二十三

优先用 non member non friend 函数替换 member 函数，毕竟一样的功能，但前者却不能访问私有成员，这才贯彻封装。此外，带来的好处也不少：这函数可以是另一个 class 的 member 函数，也可以是一个跨文件的命名空间里的函数。

## 条款二十四

如果你需要为某函数的所有参数都能进行隐式转换，那么得定义为 non-menber 函数，特别是二元运算符。此外，member 的反面不应该全是 friend.

## 条款二十六

到确实要用变量时才定义，并且直接在构造的同时初始化，不要构造后再赋值。此外，在循环里面还是外面定义变量，取决于赋值与构造析构的成本比较和变量作用域。

## 条款四十二

因为 C++ 在解析嵌套从属类型名称（nested dependent type name）时并不会优先假定它是「类型」，于是得显式地在所有嵌套从属类型名称前统统加上 `typename`.

但有两个例外：

* base class lists, 即继承的 base class 列表，毕竟其向来只能是类型即 class.
* member initialization list, 即成员初始化列表，毕竟其向来只能是对象即数据成员。

我曾对此规则产生了疑问，后来自己解决了：[嵌套从属名称在成员初始化列表如何被分别解析为类型或数据成员？](http://segmentfault.com/q/1010000004034584/a-1020000004034914)

# More Effective C++

## 条款一

当你要指向非 null 的某东西，也不会再改指向其它东西，或实现一个操作符需要直接引用，就引用；否则可以用指针。

## 条款三

不要用多态处理数组。

## 条款五

禁止定义隐式类型转换操作符，用功能对等的另一个函数取代类型转换操作符；显式用 explicit 关键字杜绝一切隐式转换，当然显式转换可行。

## 条款六

后置式 increment/decrenment 操作符要返回 const 对象；而且由于是临时对象，涉及到构造和析构，所以前置式事实上在 C++ 里性能更好；后置式操作符要调用前置式操作符。

## 条款七

禁止重载 &&, || 和 , 操作符。因为会改变「骤死式语义」成「函数调用语义」。
